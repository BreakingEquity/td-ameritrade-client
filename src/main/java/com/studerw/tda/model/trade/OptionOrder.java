package com.studerw.tda.model.trade;

import java.math.BigDecimal;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.StringJoiner;
import java.util.stream.Collectors;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Positive;
import org.apache.commons.lang3.StringUtils;

/**
 * <p>Request class used to send an option order {@link com.studerw.tda.client.TdaClient#tradeOption}.
 * Use the {@link OptionOrderBldr} instead of constructor. There are no public setters as this class
 * is intended to be immutable.</p>
 *
 * <p>
 * TDA expects symbol types to be formatted like the following: <em>MSFT_061821C120</em>. This is
 * the June 18, 2021 call at $120 for Microsoft. Or similarly, the equivalent put:
 * <em>MSFT_061821P120</em>.
 * </p>
 * <p>
 * Remeber that a quantity of 1 is actually a contract for 100. So if you set <em>quantity</em> to 1
 * with a price of $4.20, you're actual purchasing a contract for $420.
 * </p>
 */
public class OptionOrder {

  private String clientOrderId = String.valueOf(new Date().getTime());
  @NotBlank(message = "The account id cannot be empty. To use the default, use 'client.getCurrentLogin().getXmlLogIn().getAssociatedAccountId()'")
  private String accountId;
  @NotNull(message = "Option action cannot be empty - must be either 'sell', 'buy', 'sellshort' or 'buytocover'")
  private OptionAction optionAction;
  private BigDecimal actPrice;
  @NotNull(message = "expire type is required, one of [day, moc, day_ext, gtc, gtc_ext, am, pm]")
  private OptionExpire expire;
  @Pattern(message = "The expiration day must be a two digit day (e.g. 08 or 15)", regexp = "\\d{2}|null")
  private String expireDay;
  @Pattern(message = "The expiration month must be a two digit month (e.g. 08 or 11)", regexp = "\\d{2}|null")
  private String expireMonth;
  @Pattern(message = "The expiration year must be a two digit year (e.g. 20 for 2020)", regexp = "\\d{2}|null")
  private String expireYear;
  @NotNull(message = "orderType required - must be one of [market, limit, stop_market, stop_limit, tstoppercent, tstopdollar]")
  private OrderType orderType;
  private BigDecimal price;
  @NotNull(message = "the quantity must be set to 1 or more")
  @Positive(message = "Must have 1 or more for quantity")
  private Integer quantity;
  private Routing routing;
  private SpecialInstruction specialInstruction;
  @NotEmpty(message = "the equity symbol in uppercase (e.g. MSFT) is missing.")
  private String symbol;


  private OptionOrder() {
  }

  /**
   * Generated by the client software. It gets returned in the response for order matching. It is
   * optional, but a handy way to keep track of orders internally.
   *
   * @return id set by the client
   */
  public String getClientOrderId() {
    return clientOrderId;
  }

  void setClientOrderId(String clientOrderId) {
    this.clientOrderId = clientOrderId;
  }

  /**
   * The Account ID of the account in which the trade is being made. If this is not set initially,
   * the default account id of the account will be used.
   *
   * @return account id used for the order
   */
  public String getAccountId() {
    return accountId;
  }

  void setAccountId(String accountId) {
    this.accountId = accountId;
  }

  /**
   * Order action. It is required and there is no default.
   *
   * @return One of [sell, buy, sellshort, buytocover]
   */
  public OptionAction getOptionAction() {
    return optionAction;
  }

  void setOptionAction(OptionAction optionAction) {
    this.optionAction = optionAction;
  }

  /**
   * @return The stop price for stop market or stop limit orders.
   */
  public BigDecimal getActPrice() {
    return actPrice;
  }

  void setActPrice(BigDecimal actPrice) {
    this.actPrice = actPrice;
  }

  /**
   * @return One of [day, moc, day_ext, gtc, gtc_ext, am, pm]
   */
  public OptionExpire getExpire() {
    return expire;
  }

  void setExpire(OptionExpire expire) {
    this.expire = expire;
  }

  /**
   * @return Two digit expiration day, only specified if expire is set to gtc otherwise null
   */
  public String getExpireDay() {
    return expireDay;
  }

  void setExpireDay(String expireDay) {
    this.expireDay = expireDay;
  }

  /**
   * @return Two digit expiration month, only specified if expire is set to gtc otherwise null.
   */
  public String getExpireMonth() {
    return expireMonth;
  }

  void setExpireMonth(String expireMonth) {
    this.expireMonth = expireMonth;
  }

  /**
   * @return Two digit expiration year, only specified if expire is set to gtc otherwise null.
   */
  public String getExpireYear() {
    return expireYear;
  }

  void setExpireYear(String expireYear) {
    this.expireYear = expireYear;
  }

  /**
   * Case sensitive value for order type. It is required.
   *
   * @return one of [market, limit, stop_market, stop_limit, tstoppercent, tstopdollar]
   */
  public OrderType getOrderType() {
    return orderType;
  }

  void setOrderType(OrderType orderType) {
    this.orderType = orderType;
  }

  /**
   * @return Limit price for limit or stop limit orders otherwise null
   */
  public BigDecimal getPrice() {
    return price;
  }

  void setPrice(BigDecimal price) {
    this.price = price;
  }

  /**
   * @return The number of shares being bought or sold in the transaction
   */
  public Integer getQuantity() {
    return quantity;
  }

  void setQuantity(Integer quantity) {
    this.quantity = quantity;
  }

  /**
   * User specified order routing destination. Default is auto
   *
   * @return one of [auto, inet, ecn_arca]
   */
  public Routing getRouting() {
    return routing;
  }

  void setRouting(Routing routing) {
    this.routing = routing;
  }

  /**
   * Special Instructions for the order execution. Set to none if not specified
   *
   * @return one of [none, fok, aon, dnr, aon_dnr]
   */
  public SpecialInstruction getSpecialInstruction() {
    return specialInstruction;
  }

  void setSpecialInstruction(SpecialInstruction specialInstruction) {
    this.specialInstruction = specialInstruction;
  }

  /**
   * @return Equity symbol, should be uppercase, e.g. MSFT or VTSAX
   */
  public String getSymbol() {
    return StringUtils.upperCase(symbol);
  }

  void setSymbol(String symbol) {
    this.symbol = StringUtils.upperCase(symbol);
  }

  /**
   * @return list of map of query params that aren't empty or null
   */
  public Map<String, String> toQueryStringMap() {
    Map<String, String> params = new HashMap<>();

    if (StringUtils.isNotBlank(this.clientOrderId)) {
      params.put("clientorderid", this.clientOrderId);
    }
    if (StringUtils.isNotBlank(this.accountId)) {
      params.put("accountid", this.accountId);
    }
    if (this.optionAction != null) {
      params.put("action", this.optionAction.toString());
    }
    if (this.actPrice != null) {
      params.put("actprice", this.actPrice.toString());
    }
    if (this.expire != null) {
      params.put("expire", this.expire.toString());
    }
    if (StringUtils.isNotBlank(this.expireDay)) {
      params.put("exday", this.expireDay.toString());
    }
    if (StringUtils.isNotBlank(this.expireMonth)) {
      params.put("exmonth", this.expireMonth.toString());
    }
    if (StringUtils.isNotBlank(this.expireYear)) {
      params.put("exyear", this.expireYear.toString());
    }
    if (this.orderType != null) {
      params.put("ordtype", this.orderType.toString());
    }
    if (this.price != null) {
      params.put("price", this.price.toString());
    }
    if (this.quantity != null) {
      params.put("quantity", this.quantity.toString());
    }
    if (this.routing != null) {
      params.put("routing", this.routing.toString());
    }
    if (this.specialInstruction != null) {
      params.put("spinstructions", this.specialInstruction.toString());
    }
    if (StringUtils.isNotBlank(this.symbol)) {
      params.put("symbol", this.symbol.toUpperCase());
    }
    return params;
  }

  /**
   * @param key query key (e.g. orderstring)
   * @return query string of parameters separated by '~' as per TDA API requirements
   */
  public String toQueryString(String key) {
    Map<String, String> params = this.toQueryStringMap();
    String orderString = params.keySet().stream()
        .map(k -> k + "=" + params.get(k)).collect(Collectors.joining("~"));
    return orderString;
  }

  @Override
  public String toString() {
    return new StringJoiner(", ", OptionOrder.class.getSimpleName() + "[", "]")
        .add("clientOrderId='" + clientOrderId + "'")
        .add("accountId='" + accountId + "'")
        .add("optionAction=" + optionAction)
        .add("actPrice=" + actPrice)
        .add("expire=" + expire)
        .add("expireDay=" + expireDay)
        .add("expireMonth=" + expireMonth)
        .add("expireYear=" + expireYear)
        .add("orderType=" + orderType)
        .add("price=" + price)
        .add("quantity=" + quantity)
        .add("routing=" + routing)
        .add("specialInstruction=" + specialInstruction)
        .add("symbol='" + symbol + "'")
        .toString();
  }

  public static final class OptionOrderBldr {

    private String clientOrderId;
    private String accountId;
    private OptionAction optionAction;
    private BigDecimal actPrice;
    private OptionExpire expire;
    private String expireDay;
    private String expireMonth;
    private String expireYear;
    private OrderType orderType;
    private BigDecimal price;
    private Integer quantity;
    private Routing routing = Routing.auto;
    private SpecialInstruction specialInstruction = SpecialInstruction.none;
    private String symbol;

    private OptionOrderBldr() {
    }

    public static OptionOrderBldr anOptionOrder() {
      return new OptionOrderBldr();
    }

    public OptionOrderBldr withClientOrderId(String clientOrderId) {
      this.clientOrderId = clientOrderId;
      return this;
    }

    public OptionOrderBldr withAccountId(String accountId) {
      this.accountId = accountId;
      return this;
    }

    public OptionOrderBldr withAction(OptionAction optionAction) {
      this.optionAction = optionAction;
      return this;
    }

    public OptionOrderBldr withActPrice(BigDecimal actPrice) {
      this.actPrice = actPrice;
      return this;
    }

    public OptionOrderBldr withExpire(OptionExpire expire) {
      this.expire = expire;
      return this;
    }

    public OptionOrderBldr withExpireDay(String expireDay) {
      this.expireDay = expireDay;
      return this;
    }

    public OptionOrderBldr withExpireMonth(String expireMonth) {
      this.expireMonth = expireMonth;
      return this;
    }

    public OptionOrderBldr withExpireYear(String expireYear) {
      this.expireYear = expireYear;
      return this;
    }

    public OptionOrderBldr withOrderType(OrderType orderType) {
      this.orderType = orderType;
      return this;
    }

    public OptionOrderBldr withPrice(BigDecimal price) {
      this.price = price;
      return this;
    }

    public OptionOrderBldr withQuantity(Integer quantity) {
      this.quantity = quantity;
      return this;
    }

    public OptionOrderBldr withRouting(Routing routing) {
      this.routing = routing;
      return this;
    }

    public OptionOrderBldr withSpecialInstruction(SpecialInstruction specialInstruction) {
      this.specialInstruction = specialInstruction;
      return this;
    }

    public OptionOrderBldr withSymbol(String symbol) {
      this.symbol = StringUtils.upperCase(symbol);
      return this;
    }

    public OptionOrder build() {
      OptionOrder optionOrder = new OptionOrder();
      optionOrder.actPrice = this.actPrice;
      optionOrder.specialInstruction = this.specialInstruction;
      optionOrder.price = this.price;
      optionOrder.clientOrderId = this.clientOrderId;
      optionOrder.symbol = this.symbol;
      optionOrder.expireDay = this.expireDay;
      optionOrder.orderType = this.orderType;
      optionOrder.routing = this.routing;
      optionOrder.accountId = this.accountId;
      optionOrder.optionAction = this.optionAction;
      optionOrder.quantity = this.quantity;
      optionOrder.expireYear = this.expireYear;
      optionOrder.expire = this.expire;
      optionOrder.expireMonth = this.expireMonth;
      return optionOrder;
    }
  }
}

